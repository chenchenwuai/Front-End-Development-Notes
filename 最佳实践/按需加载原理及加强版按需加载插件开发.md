> 本文介绍按需加载原理、babel 插件开发、抽象语法树、并开发一个加强版的按需引入插件

## 按需加载原理

以 antd 组件库为例，来了解下为什么需要按需加载

antd 通过[index.js](https://github.com/ant-design/ant-design/blob/master/components/index.tsx)文件暴露所有的组件，比如：

```js
export { default as Button } from "./button";
export { default as Input } from "./input";
export { default as Select } from "./select";
export { default as Upload } from "./upload";
// 省略了很多
```

在我们的业务代码中，我们可以通过以下两种方式使用：

- 第一种引入方法

```js
import { Button, Input } from "antd";
```

- 第二种引入方法

```js
import Button from "antd/button";
import Input from "antd/input";
```

那么这两种方法有什么区别呢？

先来看下第一种方法：

- 第一种方法引入的是 `antd/index.js`文件暴露的模块。第三方开发者使用简单，无需关注组件的具体路径。
- 这种方法最大的缺点就是无法做到按需引入。假设我们的项目中只需要 Button 和 Input 组件，理论上打包只需要打包这两个组件的代码即可。但是，这种方式引入的是 `import { Button, Input } from "antd/index.js"`，即`antd/index.js` 文件，又由于这个文件引入了 antd 所有的组件并导出，webpack 在打包 `antd/index.js` 时，就会打包这些所有的组件的代码，造成资源浪费

再来看下第二种方法：

- 第二种方法通过指定组件的具体文件位置，比如 `import Button from "antd/button"; `来引入组件，而无需经过 `antd/index.js` 文件引入。webpack 打包时，只会打包 `antd/button` 组件的代码，即可达到按需加载的目的
- 此方法最大的缺点就是，第三方开发者需要关注组件的文件位置，同时，如果 antd 组件库组件的位置调整，就会给第三方开发者的业务带来风险

那有没有办法，既能兼顾第一种方法的引入方法，又能兼顾按需加载呢？

答案是肯定的，我们可以通过在 webpack 打包时进行特殊处理，写个 webpack loader 进行源码转换

```js
import { Button, Input } from "antd";
```

当我们识别到 `import` 的是 `antd` 的模块时，可以用 loader 将其转换成：

```js
import Button from "antd/button";
import Input from "antd/input";
```

第三方使用者无需关注底层实现细节，而是从构建层面进行转换。这也是[babel-plugin-import](https://github.com/umijs/babel-plugin-import/blob/master/README.md)的基本原理

至于在打包构建时如何识别 import 的是 antd 的模块，还是其他模块，如果你正则很强的话，当然可以通过正则表达式去识别。但首选[抽象语法树](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts)

## 抽象语法树

抽象语法树的基础知识可以看[这里](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts)，也可以通过在线的工具[ast explorer](https://astexplorer.net/)体验一下。我们可以看下以下代码转换成抽象语法树是怎样的：

```js
import util, { BB as CC } from "./util.js";
export { default as Home, AA as DD } from "./home.js";
```

![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/ast.png)

### import 语句对应的抽象语法树节点分析

从图中可以看出，`import` 语句对应的节点类型为 `ImportDeclaration`。

注意观察 `import util from './util.js';` 以及 `import { BB as CC} from './util.js';` 这两种引入方式对应的语法树节点有何不同。前者是 `ImportDefaultSpecifier` 类型，并且没有 `imported` 属性。后者是 `ImportSpecifier` 类型，拥有 `local` 以及 `imported` 属性。

`local` 以及 `imported` 的含义是什么？看下面的代码：

```js
import { BB as CC } from "./util.js";
```

显然，这句代码的意思是从 `util.js` 中导入变量 `BB`，并且重命名为 `CC`，可以这样理解：

```js
import { BB } from "./util.js";

const CC = BB;
```

在这里，`CC` 对应的就是 `local`。`BB`对应的就是 `imported`，即 `util.js` 中暴露出的变量名称

### export 语句对应的抽象语法树节点分析

从图中可以看出，`export` 语句对应的节点类型为 `ExportNamedDeclaration`。

```js
export { default as Home, AA as DD } from "./home.js";
```

这句代码和下面的方式等价：

```js
import Home from "./home.js";
import { AA as DD } from "./home.js";
export { Home, DD };
```

export 出去的 `Home` 以及 `DD` 在抽象语法树中都是 `ExportSpecifier` 节点类型，同时拥有 `local` 以及 `exported` 属性。

`local` 表示 `default` 或者 `AA`，`exported` 表示 `Home` 或者 `DD`

## babel 编译原理

babel 在处理我们的源码时，会经过以下步骤：

- 使用 [@babel/parser](https://babeljs.io/docs/en/babel-parser) 读取源代码并转换为抽象语法树，即 AST。
- 其次再使用 [@babel/traverse](https://babeljs.io/docs/en/babel-traverse) 遍历抽象语法树，并根据 visitor 修改语法树。开发者可以通过 visitor 接口注册对应的节点类型监听事件
- 最后使用 [@babel/generator](https://babeljs.io/docs/en/babel-generator) 将修改后的抽象语法树转为源代码。

在第二步修改抽象语法树节点时，可以使用 babel 官方提供给我们的 [@babel/types](https://babeljs.io/docs/en/babel-types)工具操作语法树，这个工具有点类似于 `Jquery`。

以一个简单的例子说明。假设我们有以下代码，我需要将 `javascript` 在打包时替换成 `typescript`

```js
const name = "javascript";
```

这段代码对应的抽象语法树节点如下：
![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/ast-02.png)
从图中可以看出，变量声明的类型是`VariableDeclarator`，同时`javascript` 的类型是 `StringLiteral`，因此我们可以在 `visitor` 中监听 `VariableDeclarator` 节点类型，然后判断 `init.value` 如果是 `javascript`，则替换成 `typescript`，大致思路如下：

```js
function replaceName() {
  return {
    visitor: {
      VariableDeclarator(path) {
        const node = path.node;
        if (node.init.value === "javascript") {
          node.init.value = "typescript";
        }
      },
    },
  };
}
```

如果借助 `@babel/types`，我们可以构造一个 `StringLiteral` 类型的值，并且覆盖 node.init，比如：

```js
function replaceName({ types }) {
  return {
    visitor: {
      VariableDeclarator(path) {
        const node = path.node;
        if (node.init.value === "javascript") {
          node.init = types.stringLiteral("typescript");
        }
      },
    },
  };
}
```

`StringLiteral` 类型的用法可以在 `@babel/types` 文档查看：

![image](https://github.com/lizuncong/Front-End-Development-Notes/blob/master/resource/ast-03.png)

## babel 插件开发

babel 插件开发可以查看 babel 官方提供的[插件开发指南](https://babeljs.io/docs/en/plugins#plugin-development)以及[babel handbook](https://github.com/jamiebuilds/babel-handbook)

以一个简单的逆转变量名称的插件为例：

```js
export default function reverseNamePlugin() {
  return {
    visitor: {
      Identifier(path) {
        const name = path.node.name;
        if (name === "JavaScript") {
          // reverse the name: JavaScript -> tpircSavaJ
          path.node.name = name.split("").reverse().join("");
        }
      },
    },
  };
}
```

然后在 `.babelrc` 文件中使用这个插件：

```json
{
  "plugins": ["./reverse-name-plugin"]
}
```

在`babel`编译过程中，会找出所有的名字为 `JavaScript` 变量，并逆转变量名称：

```js
const JavaScript = "hello javascript";
// 经过babel编译，插件转换后变成
const tpircSavaJ = "hello javascript";
```

从`reverseNamePlugin`可以看出，babel 插件就是一个返回对象的普通函数，返回的对象中，必须定义 `visitor` 接口，这也叫做访问者模式。在 `visitor` 接口中，我们可以监听任何抽象语法树节点类型，比如前面介绍的 `ImportDeclaration`、`ExportNamedDeclaration` 等等。然后可以操作抽象语法树的节点，比如替换变量名称等等。babel 在遍历抽象语法树时，如果遍历到我们监听的节点类型，会调用我们在 `visitor` 中注册的监听事件。
