### 开放性问题：谈谈项目中的亮点/难点
#### 规避功能型问题&业务型问题，除非是功能和业务确实复杂，例如：
+ 单点登录
+ 权限的多维度管控
+ 多组件信息的复杂共享类问题
+ 产品安全解决策略
+ 数据埋点&性能监控
+ 直播类、音视频类、实时通信类、可视化处理类...的功能处理(突出自己的知识体系面)


#### 重点讲解的是：
- 性能优化方案
  + webpack层面
  + HTTP层面
  + 页面渲染层面(包含代码渲染)
  + 骨架屏
  + 延迟/异步加载
  + 大数据渲染优化
  + 大文件传输处理
  + ...
  + 总的来说就是，强调结果，例如：之前打包/加载时间是N秒，经过我的优化后是M秒。

- 插件组件封装(敏捷化平台构建之一)
  + 公共方法库
  + 插件/组件封装：二次封装&开源级插件组件的打造
  + Vue自定义指令
  + ...
  + 总的来说，除了强调结果(例如，之前半个月开发周期，现在只需要7天)，还可以突出自己的原理/源码阅读能力

- 也可以讲解一些新技术方向的攻坚
  + Hybrid
  + 可视化
  + uni-app/flutter
  + typescript
  + node
  + ...


- react ssr
  + 代码分割懒加载
  + 数据脱水和注水
  + 图片抖动。在上传图片时在URL上添加图片宽高信息，服务端填充的时候直接获取宽高并写死
  + CSR/SSR无缝切换
  + 首屏SSR

- 流程控制
  + 最笨的就是通过条件分之去控制流程
  + 可以考虑使用状态机

- websocket

- 搜索表单，配置项框架缩短开发时间

- r-show，r-if等react指令集

- 主题设置
  + var()变量。兼容性问题，不兼容IE。
  + body上添加属性，通过属性选择器控制，配置项多的话不适合，比如颜色。

- 响应式设计
  + 通过loader提取响应式代码打包到对应的媒体类型文件中，通过link结合多媒体查询优化css文件

- 主题风格。组件可以配置风格类型，给组件设置背景图，并且设置背景色等
  + 通过伪元素设置背景图片。不过这种方法需要注意改变容器的position有没有副作用。
```html
  <div class="color-theme"></div>
  .color-theme:before{
    position: absolute;
    content: '';
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background: url(e85ae87….jpg);
    mix-blend-mode: multiply;
}
.color-theme {
    background: #12cd54;
    width: 200px;
    height: 200px;
    position: relative;
}
```



- SEO优化
谷歌搜索引擎引流从3%提升到4.5%
  + title标签
  + 元描述标记
  + 结构化数据
  + 语义化html标签
  + 图片、视频 alt相关描述信息
  + 站点地图
  + robots.txt
  + 网站内所有链接均适用描述性url，禁止使用id等链接形式

- 性能优化
  + 轮播图 slow 3G条件下11秒下降到3秒
  + 图片srcset优化。此种方法会增加html体积

- 打包构建
  + handlebars编译html片段时，如何只编译脚手架内部的cli_开头的helper，而其他handlebars语法不编译。假设有如下片段：
product.html
```html
{{#cli_import '@yy/sl-theme-shared/components/hbs/seoMeta'}}{{/cli_import}}

<section class="product-list">
    {{#if isActive}}
       <img src="/star.png" alt="Active">
    {{/if}}
    {{ color }}
</section>
```
如上，在打包编译期间，只编译cli_import helper并将seoMeta片段同步到product.html产物中，但是不编译if helper以及{{color}}
这个可以通过在编译html前，将product.html源码使用handlebars.parseWithoutProcessing转换成抽象语法树，并通过handlebars暴露出来的
visitor接口监听BlockStatement以及MustacheStatement节点并将其转换成字符串类型

  + 如何在.scss文件中使用全局设置项，假设有如下home.scss文件

home.scss
```scss
body {
  color: "{{ theme.settings.color_text }}";
  div{
  	color: red;
  }
}
```
在编译初期，需要将.scss转换成css，编译后的home.css如下：

home.css
```css
body{
  // 还是会有引号
  color: "{{ theme.settings.color_text }}";
}
body div {
 	color: red;
}
```
这样会有一个问题，在将home.css交给node端handlebars编译时，最终输出的.css会如下：
```css
body{
  color: "green";
}
body div {
 	color: red;
}
```
此时body中的color值还是会被引号包裹，这就导致最终浏览器识别不了这个值，因此需要在打包编译后期，将.css中的引号去掉，这样在将.scss文件
编译成.css文件时，产出如下：

home.css
```css
body{
  color: {{ theme.settings.color_text }};
}
body div {
 	color: red;
}
```

这个可以通过监听webpack compiler的emit钩子，使用postcss将源码转换成抽象语法树，监听Declaration，Rule，AtMedia规则，将
引号全部替换成空字符串


- 爬虫程序爬取竞品网站信息，主要用到的技术栈：
  + superagent。一个请求插件。使用axios也是可以的
  + cheerio。一个能像使用jq操作dom一样的神器
  + puppeteer。如果对方网站设置了限制爬虫，那么可以通过puppeteer开启无头浏览器的方式爬取
